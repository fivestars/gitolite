import imp
import inspect
import glob
import os

from fsqa.phabricator_vref import PhabricatorVREF


CHECKERS = dict()


def load_checkers():
    readability_dir = os.path.dirname(__file__)
    for module in glob.glob(os.path.join(readability_dir, "*.py")):
        if "__init__" in module:
            continue
        language, _ = os.path.splitext(os.path.basename(module))
        m = imp.load_module(language, *imp.find_module(language, [readability_dir]))
        try:
            CHECKERS[language] = getattr(m, language.title() + "Checker")
        except AttributeError:
            print "{language}Checker not found in {path}".format(language=language.title(),
                    path=module)


class Readability(PhabricatorVREF):
    CHECK_FAIL_MESSAGE = """
    File {filename} in
    {commit_hash}
    needs LGTM from someone with {language} readability!
    Get one of these people to review it:
    {readability}
    """

    VREF = "VREF/READABILITY"

    def check(self):
        "Returns False if a file has not been accepted by someone with readability in its language"
        for commit_hash in self.commit_hashes:
            files_in_commit = self.get_files_in_commit(commit_hash)
            accepted_by = self.commit_to_acceptors[commit_hash] | set([self.gl_user])

            for f in files_in_commit:
                for language, checker_class, in CHECKERS.items():
                    # should meet readability conditions at last commit, aka newsha
                    file_contents = self.read_git_file(f, commit=self.oldsha)
                    file_contents_new = self.read_git_file(f, commit=self.newsha)
                    checker = checker_class(f, file_contents, file_contents_new)

                    if not checker.accepted(accepted_by):
                        self.fail(filename=f, commit_hash=commit_hash, language=language,
                                readability=checker.readability)
                        return False

        return True


class ReadabilityChecker(object):
    readability = []

    def __init__(self, file_path, file_contents_old, file_contents):
        self.file_path = file_path
        self.file_contents_old = file_contents_old
        self.file_contents = file_contents

        self.checker_hash = hash(self.read_checker_file())

    def __call__(self):
        "Return True if file requires readability review"
        _, extension = os.path.splitext(self.file_path)

        return extension in self.expected_extensions

    def accepted(self, accepted_by):
        "Return True if at least one of the accepting users has readability"
        with_readability = set([user.strip("*") for user in self.readability])
        admins = set(user.strip("*") for user in self.readability if user.endswith("*"))

        # first see if the file being edited is the readability checker itself!
        if self.checker_hash == hash(self.file_contents):
            proportion = len(admins & accepted_by) / float(len(admins))
            return True if proportion > (2./3) else False

        if not self():
            return True

        return True if accepted_by & with_readability else False

    @classmethod
    def read_checker_file(cls):
        checker_path = inspect.getfile(cls)
        with open(checker_path) as checker_contents:
            return checker_contents.read()


if __name__ == "__main__":
    import sys

    load_checkers()

    oldsha, newsha, repo_path = sys.argv[1:4]
    Readability(oldsha, newsha, repo_path).check()
